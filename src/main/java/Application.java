import java.util.Iterator;
import java.util.List;

import org.hibernate.*;
import org.hibernate.Query;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
import org.hibernate.criterion.Criterion;
import org.hibernate.criterion.Restrictions;


public class Application {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//Configuration cfg = new Configuration().configure();
		Configuration cfg = new Configuration().configure("Hibernate.cfg.xml");
		//cfg = cfg.configure();//it's returning us configuration object so we are storing in the configure variable here 
		/*configure will give u configuration method here.
		 * cfg is the empty object.
		 * abc is the object which already reading our configuration from Mysql.cgf.xml
		 * line no : 7 is empty configuration
		 * line no: 8, it is overridding the line no: 7 empty cfg object with the configure() remark.
		 * 
		 * Coming to configure(), as we also have the same hibernate.cfg.xml we are not giving anything.
				ex: our cfg.xml file is named with oracle.cfg.xml then what we need to do is with in the pair of paranthesis of configure() with in double quotes we have to mention file name.
						ex: cfg=cfg.configure("oracle.cfg.xml");
		 * 
		 */
		
		//Now creating sessionfactory it is org.hibernate package only, since this is an interface we can give "new SessionFactory", we need to get the factory implementation from someone else thats why we need to call cfg.
		SessionFactory factory =cfg.buildSessionFactory();
		
		//from sessionfactory we need to get the session, we can getCurrentSession, open session, close session
		Session session = factory.openSession();
	
		/*Now, by using session object we can insert/retrieve the records.
		 * we have created a row in the database by inserting 
		 * Insert into Student values (1, 'Abc', 'VJW', 'INDIA' );
		 * we are trying to fetch the same inserted record from session object.
		 * When we are trying to fetch the data we have search for the "get" kind of method.  
		*/
		
	
		Criteria ct = session.createCriteria(Student.class);
		 Criterion cn = Restrictions.gt("student_id", 0);
				 //criterion is another conditon it's having different static methods like >=, <=, =, sizeLt 
		List<Student> result =  ct.add(cn).list();		//let's store the data in the list  
		
		//whenever we are trying to generate the data from list which is generated by list or array or  some other methods it is mandatory to check the null value or else it throws null pointer exception.
		if(result!=null && result.isEmpty())
		{
			for(Student st : result) {
				System.out.println("Student_id : " + st.getStudent_id()+ "\t Name :" +st.getStudent_name()+ "\t Age: "+ st.getStudent_age()+"\t Address: " + st.getStudent_address()+ "\t country :"+st.getCountry() + "\t Sex: "+st.getSex() +"\t NickName: " +st.getNickname());

			}
		}
		
		
		//Now, opening the transaction, to save the data into the database. But for simply getting the data from the database we dont have to open any transactions. But if we want to perform any update/insert kind of things we have to open the transaction.
		Transaction transaction = session.beginTransaction();
		
				
		//Now for storing the data in the database server we have to create the object actually
		Student st = new Student();
		st.setStudent_id(3);
		st.setStudent_name("Sindhu");
		st.setStudent_age(22);
		st.setStudent_address("VJW");
		st.setCountry("India");
	    st.setSex("f");
	    st.setNickname("sweety");
		
	    
		/*To insert the above information into the database we need to search for other method called "save"
		 * we have 3 types of session functions "save", "update", "saveOrUpdate", "get", "delete".
		 * session.save(st);
		 * session.update(st);
		 * we have many different methods in session's
		 * we just need to use CRUD operation methods.
		 * for storing we have multiple methods and we have one more method called "load" also.
		 * */
		 session.saveOrUpdate(st);
		
		/*int key =  (Integer) session.save(st);//type casted with (integer)
		  System.out.println(key);*/
		 
		//commiting transaction
		transaction.commit();
		
		/*
		// we need to execute HQL query "createQuery" is used to generate HQL query 
		Query query = session.createQuery("from Student where country ='india'  ");
		from student is equivalent to regular select * from student query
		 * in from Student => "Student" is trying to match with the Student.java particular entity class file if it doesnt match it will give an error.
		 * 
		 * So, now we internally using dialect classes. Using dialect class we trying to interact with the MySql database server.
		 * 		Then internally the HQL query translators convert the hql query"from Student" to sql query.
		 * 
		 * SO, this createQuery () is used to convert the hql query into sql query.
		 * Even if we want to create conditional queries also we can do them here by using " where country='india' "
		 * whenever we are trying to fetch the data, we have to use the field name instead of column name.  
		 * 
		 * whenever we are fetching the data instead of using column name we have to use field name.
		
		
		//we can either use "Iterator" or "List" for fetching all the records at a time. even if there are 1000 records are there also we can fetch 1000 records at a time from the table.
		
		
		//now, how can we iterate the data from the iterator object. we need to call the hash and hashNext
		Iterator<Student> it =  query.iterate();
		 * by using iterate method i will be getting iterate object over student table and we will be calling hasNext() and whenever there's a next record we will be entering inside, 
		 * 	we will be getting next record and i will be making use of it. 
		 * 		That means it wont pre-load all the list of records in this particular table.
		 * It's not going to pre-load everything here.  
		 * Whenever we are calling it.next() then it is trying to interact with the database server, that time it will be fetching the data. 
		 * to match student table country = india condition we have 3 records 
		 * 	So, whenever it fetches the first record after that it goes to the next() and then it goes to the next record available and repeats the same thing for 3 rd record also.
		 * 
		 * Earlier using list we are fetching  all the data in a single shot all the obejcts.
		 * 	Now whenever it is required then we are trying to communicate with the database server and fetching the data.
		 
		while(it.hasNext())
		{
			Student st = it.next();
			System.out.println("Student_id : " + st.getStudent_id()+ "\t Name :" +st.getStudent_name()+ "\t Age: "+ st.getStudent_age()+"\t Address: " + st.getStudent_address()+ "\t country :"+st.getCountry() + "\t Sex: "+st.getSex() +"\t NickName: " +st.getNickname());
		}
		
		
		
		 //* if we give query.list() it is generating one single select query and its fetching all the records into the students list.
		List<Student> students = query.list();//we are using list() to get list of student objects here.
		By, using query object we are using list(). we need to iterate and fetch the data so we make use for loop.
		 * 		so, that it is giving all the list of objects into the student table here
		 * 			That means it is giving complete list of records into the list of objects. This is called "early loading".
		 * Before processing list only, it is already with full of objects here. Whether we are iterating or not iterating it doesn't matter, it is full of objects here.
		 * 
		 * ex: when we have 1000's of records we need to fetch only some particular records.
		 * So, then what will happen is if we go for query.list() internally it will be creating those 1000's of objects(that particular entity objects).
		 * 		at a time in single shot itself and it will be storing them all in our list object.
		 * Obviously what will happen it will increase our memory allocation right. if we are creating more number of objects means it will be creating more memory.
		 * 
		 * 	Apart from this if we go for Iterate, what will happen is it will be creating an iterator for u, in a single shot it wll be fetching all the id's in that particular table, and whenever you required the data and whenever u r calling the next() method it will be taking those id's and 
		 * 		it will be selecting one more query for id and it will be fetching the data.
		 * That means in the Iterator, we are not storing all the objects here. So, it is not going to cause any out of memory execution s like that errors.
		 *  
		 *  here, it is something like before processing only we are getting the data here, by calling the list method with one select query.
		 *  
		 *  But if we go for iterate, whenever we needed we will be getting the data. 
		 *  This is the reason we will be calling it as "early loading" coming to LIST. ( that means before processing only we are loading everything into the list object)
		 *  and 
		 *  we will be calling "lazy loading" when it comes to ITERATOR. ( coming to iterator whenever we are calling iterator.next() then only it will be trying to interact with the database server and fetching out the data why becos when we are pushing only we are getting  the data or else we are not getting the data )
		
		for(Student st1: students)
		{
			System.out.println("Student_id : " + st1.getStudent_id()+ "\t Name :" +st1.getStudent_name()+ "\t Age: "+ st1.getStudent_age()+"\t Address: " + st1.getStudent_address()+ "\t country :"+st1.getCountry() + "\t Sex: "+st1.getSex() +"\t NickName: " +st1.getNickname());
			 
		}
	*/
	
		
		Student st1 = (Student) session.get(Student.class, 3);//here serializable is primary key || get(class<t> arg0, Serializable arg1); for class we need to pass the mapping class name which we are trying to map with the table and serializable is nothing but a primary key.
		System.out.println("Student_id : " + st1.getStudent_id()+ "\t Name :" +st1.getStudent_name()+ "\t Age: "+ st1.getStudent_age()+"\t Address: " + st1.getStudent_address()+ "\t country :"+st1.getCountry() + "\t Sex: "+st1.getSex() +"\t NickName: " +st1.getNickname());
		 
		
		session.close();
		factory.close();
		
	
	}

}


/* when to use early loading and when to use lazy loading ?
 * ex: if there are 100 records are there, to fetch all the 100 records of data into my hibernate code. 
 * 		Then if we go for early loading we will only be executing one select query and it will be fetching all the 100 data object records at the same time in a single shot.
 * 			How many times are we interacting with the database server?			
 * 				In early loading we are interacting with the database server only one time.
 * 
 * 		Then if we go for lazy loading, how many times are we interacting with the database server?
 * 	 		101 times, 1st time is to fetch the id & the rest of the 100 times is to fetch the records.
 * 				here, number of iterations to interact with the database server is increased now. if we consider in this perspective right early loading is the perfect one for us in this scenario.
 * 
 * Finally, if we want to fetch all the records it doesn't matter whether if we are using "Early Loading" or "Lazy Loading". 
 * 				But if you want to fetch a few records its better to go for "Lazy Loading".
 * 					If we want to fetch all the records then go for "Early Loading".
 * 						why because the number of interactions to the database server we are reducing. In a single shot we are fetching the data.
 * 
 * 	Early loading is before processing only it is ready with the list of required data.
 * 		Lazy Loading is while processing each and every record.
 * 
 * 
 * 
 */
 